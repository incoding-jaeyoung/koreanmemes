{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 7, "column": 0}, "map": {"version":3,"sources":["file:///Users/damanegi/Desktop/dev/KoreanMemes/src/components/ImageTranslator.tsx"],"sourcesContent":["'use client'\n\nimport React, { useRef, useEffect, useState, useCallback } from 'react'\n\ninterface SelectionBox {\n  startX: number\n  startY: number\n  width: number\n  height: number\n  id: string\n  translatedText?: string\n  isTranslating?: boolean\n}\n\ninterface ImageTranslatorProps {\n  imageFile: File\n  onTranslationComplete: (translatedImageUrl: string) => void\n  onCancel: () => void\n}\n\nexport default function ImageTranslator({ imageFile, onTranslationComplete, onCancel }: ImageTranslatorProps) {\n  const canvasRef = useRef<HTMLCanvasElement>(null)\n  const [image, setImage] = useState<HTMLImageElement | null>(null)\n  const [isDrawing, setIsDrawing] = useState(false)\n  const [currentSelection, setCurrentSelection] = useState<SelectionBox | null>(null)\n  const [selections, setSelections] = useState<SelectionBox[]>([])\n  const [isTranslating, setIsTranslating] = useState(false)\n  const [scale, setScale] = useState({ x: 1, y: 1 })\n  const [startPoint, setStartPoint] = useState<{ x: number; y: number } | null>(null)\n  const [hoveredSelection, setHoveredSelection] = useState<string | null>(null)\n  const [lastTranslatedImageUrl, setLastTranslatedImageUrl] = useState<string>('')\n\n  // 이미지 로드\n  useEffect(() => {\n    if (!imageFile) return\n    \n    const img = new Image()\n    img.onload = () => {\n      setImage(img)\n      const canvas = canvasRef.current\n      if (canvas) {\n        // 컨테이너 너비에 맞게 캔버스 크기 설정\n        const container = canvas.parentElement\n        if (container) {\n          const containerWidth = container.clientWidth\n          const imgRatio = img.width / img.height\n          \n          // 가로를 컨테이너 너비에 맞추고 비율에 따라 세로 계산\n          const displayWidth = containerWidth\n          const displayHeight = containerWidth / imgRatio\n          \n          // 캔버스 크기를 화면 표시 크기로 설정 (좌표 일치를 위해)\n          canvas.width = displayWidth\n          canvas.height = displayHeight\n          canvas.style.width = `${displayWidth}px`\n          canvas.style.height = `${displayHeight}px`\n          \n          // 스케일 비율 계산: 화면 크기 → 원본 이미지 크기\n          setScale({\n            x: img.width / displayWidth,   // 화면 좌표를 원본 좌표로 변환하는 비율\n            y: img.height / displayHeight\n          })\n          \n          // 캔버스에 이미지 그리기 (표시 크기에 맞춤)\n          const ctx = canvas.getContext('2d')\n          if (ctx) {\n            ctx.drawImage(img, 0, 0, displayWidth, displayHeight)\n          }\n        }\n      }\n    }\n    \n    const url = URL.createObjectURL(imageFile)\n    img.src = url\n    \n    return () => URL.revokeObjectURL(url)\n  }, [imageFile])\n\n  // 캔버스 그리기\n  const drawCanvas = useCallback(() => {\n    const canvas = canvasRef.current\n    const ctx = canvas?.getContext('2d')\n    if (!canvas || !ctx || !image) return\n\n    // 배경 클리어\n    ctx.clearRect(0, 0, canvas.width, canvas.height)\n    \n    // 이미지 그리기 (화면 크기에 맞춤)\n    ctx.drawImage(image, 0, 0, canvas.width, canvas.height)\n    \n    // 기존 번역된 영역들 그리기 (화면 좌표계에서 직접 그리기)\n    selections.forEach(selection => {\n      if (selection.translatedText) {\n        // 선택 영역은 화면 좌표계 기준이므로 직접 사용\n        const boxX = selection.startX\n        const boxY = selection.startY\n        const boxWidth = selection.width\n        const boxHeight = selection.height\n        \n        // 반투명 검은색 배경 (85% 투명도)\n        ctx.fillStyle = 'rgba(0, 0, 0, 0.85)'\n        ctx.fillRect(boxX, boxY, boxWidth, boxHeight)\n        \n        // 경계선 (호버된 영역은 빨간색으로 표시)\n        if (hoveredSelection === selection.id) {\n          ctx.strokeStyle = '#ff0000'\n        } else {\n          ctx.strokeStyle = '#333333'\n        }\n        ctx.lineWidth = 1\n        ctx.strokeRect(boxX, boxY, boxWidth, boxHeight)\n        \n        // X 모양 삭제 표시 (호버된 영역에만)\n        if (hoveredSelection === selection.id) {\n          ctx.strokeStyle = '#ff6666'\n          ctx.lineWidth = 2\n          const margin = Math.min(boxWidth, boxHeight) * 0.1\n          \n          // X 그리기\n          ctx.beginPath()\n          ctx.moveTo(boxX + margin, boxY + margin)\n          ctx.lineTo(boxX + boxWidth - margin, boxY + boxHeight - margin)\n          ctx.stroke()\n          \n          ctx.beginPath()\n          ctx.moveTo(boxX + boxWidth - margin, boxY + margin)\n          ctx.lineTo(boxX + margin, boxY + boxHeight - margin)\n          ctx.stroke()\n        }\n        \n        // 폰트 사이즈를 영역에 맞게 동적 계산\n        const maxTextWidth = boxWidth * 0.9\n        const maxTextHeight = boxHeight * 0.9\n        \n        // 텍스트 줄바꿈 처리\n        const words = selection.translatedText.split(' ')\n        \n        // 폰트 사이즈를 찾기 위한 이진 탐색\n        let fontSize = Math.min(boxHeight * 0.3, 40) // 시작 폰트 사이즈\n        const minFontSize = 8\n        const maxFontSize = Math.min(boxHeight * 0.5, 60)\n        let bestFontSize = minFontSize\n        \n        // 최적 폰트 사이즈 찾기\n        for (let testSize = minFontSize; testSize <= maxFontSize; testSize += 2) {\n          ctx.font = `bold ${testSize}px Arial, sans-serif`\n          \n          // 텍스트 줄바꿈 테스트\n          const lines: string[] = []\n          let currentLine = ''\n          \n          for (const word of words) {\n            const testLine = currentLine ? `${currentLine} ${word}` : word\n            const testWidth = ctx.measureText(testLine).width\n            \n            if (testWidth <= maxTextWidth) {\n              currentLine = testLine\n            } else {\n              if (currentLine) {\n                lines.push(currentLine)\n                currentLine = word\n              } else {\n                lines.push(word)\n              }\n            }\n          }\n          if (currentLine) lines.push(currentLine)\n          \n          // 총 높이 계산\n          const lineHeight = testSize * 1.3\n          const totalHeight = lines.length * lineHeight\n          \n          // 텍스트가 영역에 들어가는지 확인\n          if (totalHeight <= maxTextHeight) {\n            bestFontSize = testSize\n          } else {\n            break\n          }\n        }\n        \n        // 최종 폰트 사이즈 적용\n        fontSize = Math.max(bestFontSize, minFontSize)\n        ctx.font = `bold ${fontSize}px Arial, sans-serif`\n        ctx.fillStyle = 'white'  // 텍스트 색상을 흰색으로 변경\n        ctx.textAlign = 'center'\n        ctx.textBaseline = 'top'\n        \n        // 최종 텍스트 줄바꿈\n        const lines: string[] = []\n        let currentLine = ''\n        \n        for (const word of words) {\n          const testLine = currentLine ? `${currentLine} ${word}` : word\n          const testWidth = ctx.measureText(testLine).width\n          \n          if (testWidth <= maxTextWidth) {\n            currentLine = testLine\n          } else {\n            if (currentLine) {\n              lines.push(currentLine)\n              currentLine = word\n            } else {\n              lines.push(word)\n            }\n          }\n        }\n        if (currentLine) lines.push(currentLine)\n        \n        // 다중 라인 텍스트 그리기\n        const lineHeight = fontSize * 1.3\n        const totalTextHeight = lines.length * lineHeight\n        const startY = boxY + (boxHeight - totalTextHeight) / 2\n        \n        lines.forEach((line, index) => {\n          const lineY = startY + index * lineHeight\n          const lineX = boxX + boxWidth / 2\n          ctx.fillText(line, lineX, lineY)\n        })\n      } else if (selection.isTranslating) {\n        // 번역 중 표시 (화면 좌표계에서 직접 그리기)\n        ctx.fillStyle = 'rgba(255, 255, 0, 0.3)'\n        ctx.fillRect(selection.startX, selection.startY, selection.width, selection.height)\n        \n        ctx.strokeStyle = '#ffd700'\n        ctx.lineWidth = 2\n        ctx.strokeRect(selection.startX, selection.startY, selection.width, selection.height)\n        \n        ctx.fillStyle = 'white'  // 번역 중 텍스트도 흰색으로 변경\n        ctx.font = 'bold 16px Arial'\n        ctx.textAlign = 'center'\n        ctx.textBaseline = 'middle'\n        ctx.fillText('번역 중...', selection.startX + selection.width / 2, selection.startY + selection.height / 2)\n      }\n    })\n    \n    // 현재 선택 중인 영역 그리기 (화면 좌표계에서 직접 그리기)\n    if (currentSelection) {\n      ctx.strokeStyle = '#ff0000'\n      ctx.lineWidth = 2\n      ctx.setLineDash([5, 5])\n      ctx.strokeRect(currentSelection.startX, currentSelection.startY, currentSelection.width, currentSelection.height)\n      ctx.setLineDash([])\n    }\n  }, [image, selections, currentSelection, scale, hoveredSelection])\n\n  // 캔버스 업데이트\n  useEffect(() => {\n    drawCanvas()\n  }, [drawCanvas])\n\n  // 마우스 이벤트 핸들러들\n  const handleMouseDown = (e: React.MouseEvent<HTMLCanvasElement>) => {\n    if (!image) return\n    \n    const canvas = canvasRef.current\n    if (!canvas) return\n    \n    const rect = canvas.getBoundingClientRect()\n    // 화면 좌표를 캔버스 좌표로 변환 (캔버스와 화면이 동일한 크기이므로 직접 사용)\n    const x = e.clientX - rect.left\n    const y = e.clientY - rect.top\n    \n    // 기존 선택 영역 클릭 확인 (역순으로 체크하여 최신 영역 우선)\n    for (let i = selections.length - 1; i >= 0; i--) {\n      const selection = selections[i]\n      if (x >= selection.startX && x <= selection.startX + selection.width &&\n          y >= selection.startY && y <= selection.startY + selection.height) {\n        // 기존 영역 클릭 시 삭제\n        setSelections(prev => prev.filter(sel => sel.id !== selection.id))\n        return\n      }\n    }\n    \n    // 새로운 영역 선택 시작\n    setIsDrawing(true)\n    setStartPoint({ x, y })\n    setCurrentSelection({\n      id: `selection-${Date.now()}`,\n      startX: x,\n      startY: y,\n      width: 0,\n      height: 0,\n      isTranslating: false,\n      translatedText: ''\n    })\n  }\n\n  const handleMouseMove = (e: React.MouseEvent<HTMLCanvasElement>) => {\n    const canvas = canvasRef.current\n    if (!canvas) return\n    \n    const rect = canvas.getBoundingClientRect()\n    // 화면 좌표를 캔버스 좌표로 변환 (캔버스와 화면이 동일한 크기이므로 직접 사용)\n    const x = e.clientX - rect.left\n    const y = e.clientY - rect.top\n    \n    // 호버된 선택 영역 찾기\n    let hoveredId: string | null = null\n    for (let i = selections.length - 1; i >= 0; i--) {\n      const selection = selections[i]\n      if (x >= selection.startX && x <= selection.startX + selection.width &&\n          y >= selection.startY && y <= selection.startY + selection.height) {\n        hoveredId = selection.id\n        break\n      }\n    }\n    setHoveredSelection(hoveredId)\n    \n    // 드래그 중인 경우\n    if (isDrawing && startPoint && image) {\n      const currentX = x\n      const currentY = y\n      \n      const width = currentX - startPoint.x\n      const height = currentY - startPoint.y\n      \n      setCurrentSelection(prev => prev ? {\n        ...prev,\n        width: Math.abs(width),\n        height: Math.abs(height),\n        startX: width < 0 ? currentX : startPoint.x,\n        startY: height < 0 ? currentY : startPoint.y\n      } : null)\n      \n      // 캔버스 다시 그리기\n      drawCanvas()\n    }\n  }\n\n  // 우클릭 컨텍스트 메뉴\n  const handleContextMenu = (e: React.MouseEvent<HTMLCanvasElement>) => {\n    e.preventDefault()\n    \n    if (!image) return\n    \n    const canvas = canvasRef.current\n    if (!canvas) return\n    \n    const rect = canvas.getBoundingClientRect()\n    // 화면 좌표를 캔버스 좌표로 변환 (캔버스와 화면이 동일한 크기이므로 직접 사용)\n    const x = e.clientX - rect.left\n    const y = e.clientY - rect.top\n    \n    // 우클릭한 위치의 선택 영역 찾기\n    for (let i = selections.length - 1; i >= 0; i--) {\n      const selection = selections[i]\n      if (x >= selection.startX && x <= selection.startX + selection.width &&\n          y >= selection.startY && y <= selection.startY + selection.height) {\n        // 해당 영역 삭제\n        setSelections(prev => prev.filter(sel => sel.id !== selection.id))\n        return\n      }\n    }\n  }\n\n  const handleMouseUp = async () => {\n    if (!isDrawing || !currentSelection) return\n\n    setIsDrawing(false)\n\n    // 너무 작은 선택 영역은 무시\n    if (Math.abs(currentSelection.width) < 20 || Math.abs(currentSelection.height) < 20) {\n      setCurrentSelection(null)\n      return\n    }\n\n    // 음수 크기 정규화\n    const normalizedSelection = {\n      ...currentSelection,\n      startX: currentSelection.width < 0 ? currentSelection.startX + currentSelection.width : currentSelection.startX,\n      startY: currentSelection.height < 0 ? currentSelection.startY + currentSelection.height : currentSelection.startY,\n      width: Math.abs(currentSelection.width),\n      height: Math.abs(currentSelection.height),\n      isTranslating: true\n    }\n\n    // 선택 영역을 목록에 추가\n    setSelections(prev => [...prev, normalizedSelection])\n    setCurrentSelection(null)\n\n    // OCR 및 번역 수행\n    await translateSelectedArea(normalizedSelection)\n  }\n\n  // 선택된 영역 번역\n  const translateSelectedArea = async (selection: SelectionBox) => {\n    try {\n      // 선택된 영역의 이미지 데이터 추출\n      const canvas = document.createElement('canvas')\n      const ctx = canvas.getContext('2d')\n      if (!ctx || !image) return\n\n      // 화면 좌표를 원본 이미지 좌표로 변환\n      const originalX = selection.startX * scale.x\n      const originalY = selection.startY * scale.y\n      const originalWidth = selection.width * scale.x\n      const originalHeight = selection.height * scale.y\n\n      canvas.width = originalWidth\n      canvas.height = originalHeight\n\n      // 선택된 영역만 캔버스에 그리기 (원본 이미지에서 해당 영역 추출)\n      ctx.drawImage(\n        image,\n        originalX, originalY, originalWidth, originalHeight,\n        0, 0, originalWidth, originalHeight\n      )\n\n      // 캔버스를 Blob으로 변환\n      const blob = await new Promise<Blob>((resolve) => {\n        canvas.toBlob((blob) => resolve(blob!), 'image/png')\n      })\n\n      // FormData로 API 호출\n      const formData = new FormData()\n      formData.append('image', blob, 'selection.png')\n      formData.append('ocrOnly', 'true')\n\n      const response = await fetch('/api/upload', {\n        method: 'POST',\n        body: formData\n      })\n\n      const result = await response.json()\n      \n      if (result.success && result.translatedText) {\n        // 번역 완료 - 선택 영역 업데이트\n        setSelections(prev => prev.map(sel => \n          sel.id === selection.id \n            ? { ...sel, translatedText: result.translatedText, isTranslating: false }\n            : sel\n        ))\n      } else {\n        // 번역 실패 - 선택 영역 제거\n        setSelections(prev => prev.filter(sel => sel.id !== selection.id))\n      }\n    } catch (error) {\n      console.error('Translation error:', error)\n      setSelections(prev => prev.filter(sel => sel.id !== selection.id))\n    }\n  }\n\n  // 번역된 영역이 변경될 때마다 자동으로 번역된 이미지 생성\n  useEffect(() => {\n    const autoGenerateTranslatedImage = async () => {\n      // 번역된 영역이 있고, 모든 번역이 완료된 경우에만 실행\n      const translatedSelections = selections.filter(sel => sel.translatedText && !sel.isTranslating)\n      if (translatedSelections.length === 0) return\n      \n      // 번역 중인 영역이 있으면 대기\n      if (selections.some(sel => sel.isTranslating)) return\n\n      // 자동으로 번역된 이미지 생성\n      try {\n        const translatedImageUrl = await generateTranslatedImage()\n        if (translatedImageUrl && translatedImageUrl !== lastTranslatedImageUrl) {\n          setLastTranslatedImageUrl(translatedImageUrl)\n          // 상위 컴포넌트에 자동으로 전달\n          onTranslationComplete(translatedImageUrl)\n        }\n      } catch (error) {\n        console.error('Auto translation generation error:', error)\n      }\n    }\n\n    autoGenerateTranslatedImage()\n  }, [selections, onTranslationComplete, lastTranslatedImageUrl])\n\n  // 번역된 이미지 생성 함수 (handleComplete에서 분리)\n  const generateTranslatedImage = async (): Promise<string | null> => {\n    if (selections.length === 0) return null\n    if (selections.some(sel => sel.isTranslating)) return null\n\n    try {\n      const canvas = document.createElement('canvas')\n      const ctx = canvas.getContext('2d')\n      if (!ctx || !image) return null\n\n      canvas.width = image.width\n      canvas.height = image.height\n\n      // 원본 이미지 그리기\n      ctx.drawImage(image, 0, 0)\n\n      // 번역된 텍스트들 그리기\n      selections.forEach(selection => {\n        if (selection.translatedText) {\n          // 화면 좌표를 원본 이미지 좌표로 변환\n          const realX = selection.startX * scale.x\n          const realY = selection.startY * scale.y\n          const realWidth = selection.width * scale.x\n          const realHeight = selection.height * scale.y\n          \n          // 반투명 검은색 배경 (70% 투명도)\n          ctx.fillStyle = 'rgba(0, 0, 0, 0.7)'\n          ctx.fillRect(realX, realY, realWidth, realHeight)\n          \n          // 경계선\n          ctx.strokeStyle = '#333333'\n          ctx.lineWidth = 1\n          ctx.strokeRect(realX, realY, realWidth, realHeight)\n          \n          // 폰트 사이즈를 영역에 맞게 동적 계산\n          const maxTextWidth = realWidth * 0.9\n          const maxTextHeight = realHeight * 0.9\n          \n          // 텍스트 줄바꿈 처리\n          const words = selection.translatedText.split(' ')\n          \n          // 폰트 사이즈를 찾기 위한 계산\n          const minFontSize = 8\n          const maxFontSize = Math.min(realHeight * 0.5, 60)\n          let bestFontSize = minFontSize\n          \n          // 최적 폰트 사이즈 찾기\n          for (let testSize = minFontSize; testSize <= maxFontSize; testSize += 2) {\n            ctx.font = `bold ${testSize}px Arial, sans-serif`\n            \n            // 텍스트 줄바꿈 테스트\n            const lines: string[] = []\n            let currentLine = ''\n            \n            for (const word of words) {\n              const testLine = currentLine ? `${currentLine} ${word}` : word\n              const testWidth = ctx.measureText(testLine).width\n              \n              if (testWidth <= maxTextWidth) {\n                currentLine = testLine\n              } else {\n                if (currentLine) {\n                  lines.push(currentLine)\n                  currentLine = word\n                } else {\n                  lines.push(word)\n                }\n              }\n            }\n            if (currentLine) lines.push(currentLine)\n            \n            // 총 높이 계산\n            const lineHeight = testSize * 1.3\n            const totalHeight = lines.length * lineHeight\n            \n            // 텍스트가 영역에 들어가는지 확인\n            if (totalHeight <= maxTextHeight) {\n              bestFontSize = testSize\n            } else {\n              break\n            }\n          }\n          \n          // 최종 폰트 사이즈 적용\n          const fontSize = Math.max(bestFontSize, minFontSize)\n          ctx.font = `bold ${fontSize}px Arial, sans-serif`\n          ctx.fillStyle = 'white'\n          ctx.textAlign = 'center'\n          ctx.textBaseline = 'top'\n          \n          const centerX = realX + realWidth / 2\n          \n          // 최종 텍스트 줄바꿈\n          const lines: string[] = []\n          let currentLine = ''\n          \n          for (const word of words) {\n            const testLine = currentLine ? `${currentLine} ${word}` : word\n            const testWidth = ctx.measureText(testLine).width\n            \n            if (testWidth <= maxTextWidth) {\n              currentLine = testLine\n            } else {\n              if (currentLine) {\n                lines.push(currentLine)\n                currentLine = word\n              } else {\n                lines.push(word)\n              }\n            }\n          }\n          if (currentLine) lines.push(currentLine)\n          \n          const lineHeight = fontSize * 1.3\n          const totalTextHeight = lines.length * lineHeight\n          const startY = realY + (realHeight - totalTextHeight) / 2\n          \n          lines.forEach((line, index) => {\n            const lineY = startY + index * lineHeight\n            ctx.fillText(line, centerX, lineY)\n          })\n        }\n      })\n\n      // 캔버스를 Blob으로 변환\n      const blob = await new Promise<Blob>((resolve) => {\n        canvas.toBlob((blob) => resolve(blob!), 'image/jpeg', 0.85)\n      })\n\n      // Cloudinary 업로드\n      const formData = new FormData()\n      formData.append('image', blob, 'translated.jpg')\n      formData.append('translateImage', 'false') // 이미 번역된 이미지\n\n      const response = await fetch('/api/upload', {\n        method: 'POST',\n        body: formData\n      })\n\n      const result = await response.json()\n      \n      if (result.success) {\n        return result.imageUrl\n      }\n      return null\n    } catch (error) {\n      console.error('Generate translated image error:', error)\n      return null\n    }\n  }\n\n  // 완료된 이미지 생성\n  const handleComplete = async () => {\n    if (selections.length === 0) {\n      return\n    }\n\n    if (selections.some(sel => sel.isTranslating)) {\n      return\n    }\n\n    setIsTranslating(true)\n\n    try {\n      const translatedImageUrl = await generateTranslatedImage()\n      if (translatedImageUrl) {\n        setLastTranslatedImageUrl(translatedImageUrl)\n        onTranslationComplete(translatedImageUrl)\n      }\n    } catch (error) {\n      console.error('Complete error:', error)\n    } finally {\n      setIsTranslating(false)\n    }\n  }\n\n  // 선택 영역 삭제\n  const handleClearSelections = () => {\n    setSelections([])\n    setCurrentSelection(null)\n  }\n\n  return (\n    <div className=\"space-y-4\">\n      <div className=\"bg-white rounded-lg shadow-sm border\">\n        <div className=\"p-4\">\n          <div className=\"text-center space-y-4\">\n            <h3 className=\"text-lg font-semibold\">이미지 번역 편집기</h3>\n            <div className=\"text-sm text-gray-600 space-y-1\">\n              <p>마우스로 드래그하여 번역할 텍스트 영역을 선택하세요</p>\n              <p className=\"text-xs\">\n                💡 <strong>팁:</strong> 선택된 영역을 <span className=\"text-red-600\">클릭</span>하거나 <span className=\"text-red-600\">우클릭</span>하면 개별 삭제됩니다\n              </p>\n            </div>\n            \n            <div className=\"flex justify-center\">\n              <div className=\"w-full\">\n                <canvas\n                  ref={canvasRef}\n                  onMouseDown={handleMouseDown}\n                  onMouseMove={handleMouseMove}\n                  onMouseUp={handleMouseUp}\n                  onContextMenu={handleContextMenu}\n                  className=\"cursor-crosshair block w-full border border-gray-300 rounded-lg\"\n                />\n              </div>\n            </div>\n            \n            <div className=\"flex gap-2 justify-center\">\n              <button\n                onClick={handleClearSelections}\n                disabled={selections.length === 0}\n                className=\"px-4 py-2 border border-gray-300 rounded-lg text-gray-700 hover:bg-gray-50 transition-colors disabled:opacity-50 disabled:cursor-not-allowed\"\n              >\n                선택 초기화\n              </button>\n              <button\n                onClick={handleComplete}\n                disabled={selections.length === 0 || isTranslating}\n                className=\"px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 transition-colors disabled:opacity-50 disabled:cursor-not-allowed\"\n              >\n                {isTranslating ? '처리 중...' : '번역 완료'}\n              </button>\n              <button\n                onClick={onCancel}\n                className=\"px-4 py-2 border border-gray-300 rounded-lg text-gray-700 hover:bg-gray-50 transition-colors\"\n              >\n                취소\n              </button>\n            </div>\n            \n            {selections.length > 0 && (\n              <div className=\"text-sm text-gray-600\">\n                선택된 영역: {selections.length}개 \n                {selections.filter(s => s.translatedText).length > 0 && \n                  ` (번역 완료: ${selections.filter(s => s.translatedText).length}개)`\n                }\n              </div>\n            )}\n          </div>\n        </div>\n      </div>\n    </div>\n  )\n} "],"names":[],"mappings":"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","debugId":null}}]
}