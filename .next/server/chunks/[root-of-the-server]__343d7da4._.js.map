{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 55, "column": 0}, "map": {"version":3,"sources":["file:///Users/damanegi/Desktop/dev/KoreanMemes/src/lib/imageTranslator.ts"],"sourcesContent":["import Tesseract from 'tesseract.js'\nimport OpenAI from 'openai'\nimport { createCanvas, loadImage, CanvasRenderingContext2D } from 'canvas'\nimport sharp from 'sharp'\n\nconst openai = new OpenAI({\n  apiKey: process.env.OPENAI_API_KEY,\n})\n\ninterface TextBlock {\n  text: string\n  bbox: {\n    x0: number\n    y0: number\n    x1: number\n    y1: number\n  }\n}\n\n// 한글 감지 함수\nfunction containsKorean(text: string): boolean {\n  const koreanRegex = /[ㄱ-ㅎ|ㅏ-ㅣ|가-힣]/\n  return koreanRegex.test(text)\n}\n\n// 텍스트 줄바꿈 처리 함수\nfunction wrapText(ctx: CanvasRenderingContext2D, text: string, maxWidth: number): string[] {\n  const words = text.split(' ')\n  const lines: string[] = []\n  let currentLine = ''\n\n  for (const word of words) {\n    const testLine = currentLine ? `${currentLine} ${word}` : word\n    const testWidth = ctx.measureText(testLine).width\n    \n    if (testWidth <= maxWidth) {\n      currentLine = testLine\n    } else {\n      if (currentLine) {\n        lines.push(currentLine)\n        currentLine = word\n      } else {\n        // 단어 자체가 너무 길면 그대로 추가\n        lines.push(word)\n      }\n    }\n  }\n  \n  if (currentLine) {\n    lines.push(currentLine)\n  }\n  \n  return lines\n}\n\n// GPT로 번역\nasync function translateWithGPT(koreanText: string): Promise<string> {\n  try {\n    const response = await openai.chat.completions.create({\n      model: \"gpt-4o-mini\",\n      messages: [\n        {\n          role: \"system\",\n          content: `You are a translator for Korean memes and casual content. Focus on literal translation while preserving the original tone and humor.\n\nGUIDELINES:\n• Stay close to the literal meaning of the original Korean text\n• Preserve the casual, humorous, or sarcastic tone of the original\n• Keep translations concise and punchy\n• Use natural English expressions but avoid excessive creative interpretation\n• Maintain the original sentence structure when possible\n• Use simple, direct language that fits the meme format\n• Preserve Korean cultural nuances with brief, natural explanations if needed\n• Avoid adding extra commentary or lengthy explanations\n\nEXAMPLES:\nKorean: \"야, 니는 옷이다 어디 갔나?\"\nEnglish: \"Hey, where'd your clothes go?\"\n\nKorean: \"눈 개높음\"\nEnglish: \"Standards way too high\"\n\nKorean: \"저 다음 주 전역이라 다 나눠줬습니다\"\nEnglish: \"Getting discharged next week so I gave them all away\"\n\nKeep it simple, direct, and true to the original meaning while maintaining the casual tone.`\n        },\n        {\n          role: \"user\",\n          content: `Translate this Korean text, staying close to the literal meaning while keeping the tone: \"${koreanText}\"`\n        }\n      ],\n      max_tokens: 150, // 토큰 수 줄임\n      temperature: 0.3, // 창의성 줄임\n    })\n\n    return response.choices[0]?.message?.content?.trim() || koreanText\n  } catch (error) {\n    console.error('Translation error:', error)\n    return koreanText // 번역 실패 시 원본 반환\n  }\n}\n\n// 메인 번역 함수\nexport async function translateImageText(imageBuffer: Buffer): Promise<Buffer> {\n  try {\n    console.log('Starting image translation...')\n\n    // 1. 단순하게 원본 이미지로만 OCR 수행\n    const worker = await Tesseract.createWorker('kor', 1, {\n      logger: m => console.log('OCR Progress:', m.status, m.progress)\n    })\n\n    let result\n    try {\n      // 2. 원본 이미지로 OCR 수행\n      console.log('Starting OCR with original image...')\n      result = await worker.recognize(imageBuffer)\n      console.log('OCR completed:', result.data.text)\n      console.log('OCR confidence:', result.data.confidence)\n    } finally {\n      // Worker 정리\n      await worker.terminate()\n    }\n\n    // 3. 한글 텍스트 블록 찾기 - 실제 위치 우선 감지\n    const koreanBlocks: TextBlock[] = []\n    \n    // OCR 데이터 처리\n    const ocrData = result.data as unknown\n    \n    // 먼저 paragraphs 단위로 시도 (가장 정확한 단위)\n    if (ocrData && typeof ocrData === 'object' && 'paragraphs' in ocrData) {\n      const paragraphs = (ocrData as { paragraphs: Array<{ text: string; bbox: { x0: number; y0: number; x1: number; y1: number }; confidence: number }> }).paragraphs\n      \n      for (const paragraph of paragraphs) {\n        if (paragraph.text && paragraph.bbox && containsKorean(paragraph.text)) {\n          console.log('Korean paragraph found:', paragraph.text, 'at position:', paragraph.bbox)\n          koreanBlocks.push({\n            text: paragraph.text,\n            bbox: {\n              x0: paragraph.bbox.x0,\n              y0: paragraph.bbox.y0,\n              x1: paragraph.bbox.x1,\n              y1: paragraph.bbox.y1\n            }\n          })\n        }\n      }\n    }\n\n    // paragraphs가 없으면 라인 단위로 시도\n    if (koreanBlocks.length === 0 && ocrData && typeof ocrData === 'object' && 'lines' in ocrData) {\n      const lines = (ocrData as { lines: Array<{ text: string; bbox: { x0: number; y0: number; x1: number; y1: number }; confidence: number }> }).lines\n      \n      for (const line of lines) {\n        if (line.text && line.bbox && containsKorean(line.text)) {\n          console.log('Korean line found:', line.text, 'at position:', line.bbox)\n          koreanBlocks.push({\n            text: line.text,\n            bbox: {\n              x0: line.bbox.x0,\n              y0: line.bbox.y0,\n              x1: line.bbox.x1,\n              y1: line.bbox.y1\n            }\n          })\n        }\n      }\n    }\n\n    // 라인이 없으면 단어 단위로 시도하고 그룹화\n    if (koreanBlocks.length === 0 && ocrData && typeof ocrData === 'object' && 'words' in ocrData) {\n      const words = (ocrData as { words: Array<{ text: string; bbox: { x0: number; y0: number; x1: number; y1: number }; confidence: number }> }).words\n      \n      const koreanWords = words.filter(word => word.text && word.bbox && containsKorean(word.text))\n      \n      if (koreanWords.length > 0) {\n        console.log(`Found ${koreanWords.length} Korean words, combining into blocks`)\n        \n        // 인접한 한글 단어들을 그룹화\n        const groupedWords = []\n        let currentGroup = [koreanWords[0]]\n        \n        for (let i = 1; i < koreanWords.length; i++) {\n          const currentWord = koreanWords[i]\n          const lastWord = currentGroup[currentGroup.length - 1]\n          \n          // 수직 거리로 같은 라인인지 판단 (높이 차이가 작으면 같은 라인)\n          const verticalDistance = Math.abs(currentWord.bbox.y0 - lastWord.bbox.y0)\n          const avgHeight = (currentWord.bbox.y1 - currentWord.bbox.y0 + lastWord.bbox.y1 - lastWord.bbox.y0) / 2\n          \n          if (verticalDistance < avgHeight * 0.5) {\n            // 같은 라인으로 판단\n            currentGroup.push(currentWord)\n          } else {\n            // 새로운 라인 시작\n            groupedWords.push(currentGroup)\n            currentGroup = [currentWord]\n          }\n        }\n        groupedWords.push(currentGroup) // 마지막 그룹 추가\n        \n        // 각 그룹을 텍스트 블록으로 변환\n        for (const group of groupedWords) {\n          const combinedText = group.map(w => w.text).join(' ')\n          const minX = Math.min(...group.map(w => w.bbox.x0))\n          const minY = Math.min(...group.map(w => w.bbox.y0))\n          const maxX = Math.max(...group.map(w => w.bbox.x1))\n          const maxY = Math.max(...group.map(w => w.bbox.y1))\n          \n          console.log('Korean text block found:', combinedText, 'at position:', { x0: minX, y0: minY, x1: maxX, y1: maxY })\n          koreanBlocks.push({\n            text: combinedText,\n            bbox: { x0: minX, y0: minY, x1: maxX, y1: maxY }\n          })\n        }\n      }\n    }\n\n    // 마지막 fallback - 전체 텍스트로 처리하되 정확한 위치 찾기 시도\n    if (koreanBlocks.length === 0 && result.data && result.data.text) {\n      const fullText = result.data.text.trim()\n      if (containsKorean(fullText)) {\n        console.log('Korean text found (fallback):', fullText)\n        \n        // 원본 이미지 크기 가져오기\n        const metadata = await sharp(imageBuffer).metadata()\n        const width = metadata.width || 400\n        const height = metadata.height || 300\n        \n        // 이미지 하단 영역에 배치 (보통 한글 텍스트가 하단에 있음)\n        koreanBlocks.push({\n          text: fullText,\n          bbox: {\n            x0: Math.floor(width * 0.1),\n            y0: Math.floor(height * 0.6), // 하단 60% 위치부터\n            x1: Math.floor(width * 0.9),\n            y1: Math.floor(height * 0.9)  // 하단 90% 위치까지\n          }\n        })\n      }\n    }\n\n    // 한글이 없으면 원본 반환\n    if (koreanBlocks.length === 0) {\n      console.log('No Korean text found, returning original image')\n      return imageBuffer\n    }\n\n    console.log(`Found ${koreanBlocks.length} Korean text blocks`)\n\n    // 4. 이미지 형식 변환 (webp 등 지원을 위해 PNG로 통일)\n    const processedImageBuffer = await sharp(imageBuffer)\n      .png()\n      .toBuffer()\n\n    // 5. 변환된 이미지로 Canvas 작업\n    const originalImage = await loadImage(processedImageBuffer)\n    const canvas = createCanvas(originalImage.width, originalImage.height)\n    const ctx = canvas.getContext('2d')\n\n    // 원본 이미지 그리기\n    ctx.drawImage(originalImage, 0, 0)\n\n    // 6. 각 한글 블록을 영어로 번역하여 정확한 위치에 교체\n    for (const block of koreanBlocks) {\n      const translatedText = await translateWithGPT(block.text)\n      console.log(`Translated: \"${block.text}\" → \"${translatedText}\"`)\n\n      // 한글 텍스트 위치 정보\n      const { bbox } = block\n      const originalWidth = bbox.x1 - bbox.x0\n      const originalHeight = bbox.y1 - bbox.y0\n      \n      console.log(`Replacing text at: ${bbox.x0},${bbox.y0} size: ${originalWidth}x${originalHeight}`)\n\n      // 텍스트 위주 이미지 감지 (이미지 대비 텍스트 영역이 큰 경우)\n      const imageArea = canvas.width * canvas.height\n      const textArea = originalWidth * originalHeight\n      const textRatio = textArea / imageArea\n      const isTextHeavyImage = textRatio > 0.15 // 텍스트 영역이 이미지의 15% 이상\n      \n      console.log(`Text ratio: ${(textRatio * 100).toFixed(1)}%, Text-heavy image: ${isTextHeavyImage}`)\n\n      // 폰트 크기 계산 - 텍스트 위주 이미지는 고정 크기 사용\n      let fontSize\n      if (isTextHeavyImage) {\n        // 텍스트 위주 이미지: 20px로 고정하여 일관성 확보\n        fontSize = 20\n      } else {\n        // 일반 이미지: 기존 방식\n        fontSize = Math.min(originalHeight * 0.8, originalWidth / translatedText.length * 1.5)\n        fontSize = Math.max(fontSize, 12) // 최소 크기\n        fontSize = Math.min(fontSize, originalHeight * 0.9) // 최대 크기\n      }\n      \n      ctx.font = `bold ${fontSize}px Arial, sans-serif`\n      ctx.textAlign = 'center'\n      ctx.textBaseline = 'middle'\n\n      // 텍스트 줄바꿈 처리 - 텍스트 위주 이미지는 더 넓은 영역 활용\n      let maxTextWidth\n      if (isTextHeavyImage) {\n        // 텍스트 위주 이미지: 한글 영역 너비의 95% 활용\n        maxTextWidth = originalWidth * 0.95\n      } else {\n        // 일반 이미지: 한글 영역의 85% 활용\n        maxTextWidth = originalWidth * 0.85\n      }\n      \n      const lines = wrapText(ctx, translatedText, maxTextWidth)\n      \n      // 다중 라인 텍스트 크기 계산\n      const lineHeight = fontSize * 1.5 // 줄 간격 늘림 (1.3 → 1.5)\n      const totalTextHeight = lines.length * lineHeight\n      const maxLineWidth = Math.max(...lines.map(line => ctx.measureText(line).width))\n      \n      // 박스 크기 계산 - 텍스트가 완전히 들어가도록 충분한 크기\n      const padding = isTextHeavyImage ? 20 : 10 // 패딩 증가\n      let boxWidth, boxHeight\n      \n      if (isTextHeavyImage) {\n        // 텍스트 위주 이미지: 텍스트에 맞춘 박스 크기 + 충분한 여유공간\n        boxWidth = maxLineWidth + padding * 2\n        boxHeight = totalTextHeight + padding * 2\n        \n        // 박스가 한글 영역보다 작으면 한글 영역에 맞춤\n        boxWidth = Math.max(boxWidth, originalWidth + 20) // 한글 영역보다 최소 20px 크게\n        boxHeight = Math.max(boxHeight, originalHeight + 20) // 한글 영역보다 최소 20px 크게\n      } else {\n        // 일반 이미지: 기존 방식\n        boxWidth = Math.min(maxLineWidth + padding * 2, originalWidth)\n        boxHeight = Math.min(totalTextHeight + padding * 2, originalHeight)\n      }\n      \n      // 박스 위치 계산\n      let boxX, boxY\n      if (isTextHeavyImage) {\n        // 텍스트 위주 이미지: 한글 영역을 완전히 덮도록 확장된 박스\n        // 한글 영역보다 약간 더 크게 만들어서 완전히 덮기\n        const expandMargin = 10 // 한글 영역 주변으로 10px 확장\n        boxWidth = Math.min(boxWidth, originalWidth + expandMargin * 2) // 한글 영역보다 약간 크게\n        boxHeight = Math.max(boxHeight, originalHeight + expandMargin * 2) // 한글 영역보다 약간 크게\n        \n        // 한글 텍스트 영역을 중심으로 하되 완전히 덮도록 위치 계산\n        boxX = bbox.x0 - expandMargin // 한글 시작점에서 여백만큼 왼쪽으로\n        boxY = bbox.y0 - expandMargin // 한글 시작점에서 여백만큼 위로\n        \n        // 박스가 이미지를 벗어나지 않도록 조정\n        if (boxX < 0) {\n          boxWidth += boxX // 박스 너비에 음수값 추가 (실제로는 감소)\n          boxX = 0\n        }\n        if (boxY < 0) {\n          boxHeight += boxY // 박스 높이에 음수값 추가 (실제로는 감소)\n          boxY = 0\n        }\n        if (boxX + boxWidth > canvas.width) {\n          boxWidth = canvas.width - boxX\n        }\n        if (boxY + boxHeight > canvas.height) {\n          boxHeight = canvas.height - boxY\n        }\n        \n        console.log(`Covering Korean completely: Korean(${bbox.x0}, ${bbox.y0}, ${originalWidth}x${originalHeight}) -> Box(${boxX}, ${boxY}, ${boxWidth}x${boxHeight})`)\n      } else {\n        // 일반 이미지: 한글 텍스트 영역 중앙에 배치\n        const koreanCenterX = bbox.x0 + originalWidth / 2\n        const koreanCenterY = bbox.y0 + originalHeight / 2\n        boxX = koreanCenterX - boxWidth / 2\n        boxY = koreanCenterY - boxHeight / 2\n      }\n      \n      console.log(`Final box position: (${boxX}, ${boxY}) size: ${boxWidth}x${boxHeight} in image: ${canvas.width}x${canvas.height}`)\n      console.log(`Text lines: ${lines.length}, line height: ${lineHeight}, font size: ${fontSize}`)\n      \n      // 한글 텍스트를 완전히 덮는 흰색 배경\n      ctx.fillStyle = 'white'\n      ctx.fillRect(boxX, boxY, boxWidth, boxHeight)\n      \n      // 깔끔한 경계선\n      ctx.strokeStyle = '#ddd'\n      ctx.lineWidth = 0.5\n      ctx.strokeRect(boxX, boxY, boxWidth, boxHeight)\n\n      // 다중 라인 영어 텍스트를 박스 중앙에 그리기\n      ctx.fillStyle = 'black'\n      ctx.textAlign = 'center'\n      ctx.textBaseline = 'top' // 'middle'에서 'top'으로 변경하여 더 정확한 위치 계산\n      \n      // 전체 텍스트 블록의 시작 Y 위치 계산 (박스 중앙에 텍스트 배치)\n      const textAreaHeight = totalTextHeight\n      const startY = boxY + (boxHeight - textAreaHeight) / 2\n      \n      // 각 라인을 그리기\n      lines.forEach((line, index) => {\n        const lineY = startY + index * lineHeight + fontSize * 0.2 // 약간의 상단 여백 추가\n        const lineX = boxX + boxWidth / 2\n        ctx.fillText(line, lineX, lineY)\n      })\n    }\n\n    // 7. Canvas를 Buffer로 변환\n    const canvasBuffer = canvas.toBuffer('image/png')\n    \n    // 8. 적당한 품질로 최적화\n    const optimizedBuffer = await sharp(canvasBuffer)\n      .jpeg({ quality: 85 })\n      .toBuffer()\n\n    console.log('Simple image translation completed successfully')\n    return optimizedBuffer\n\n  } catch (error) {\n    console.error('Image translation failed:', error)\n    // 오류 발생 시 원본 이미지 반환\n    return imageBuffer\n  }\n} "],"names":[],"mappings":"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","debugId":null}}]
}